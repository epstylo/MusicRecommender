Describe in a high level the solution you have in mind
Though it is not currently implemented, I have the general solution in mind. I will use the songs that have been listened to by the user, and assign the user with "genre" tallies that reflect how much the user likes each genre. When getting song recommendations, I will iterate through the list of followees and cross-reference to find the followees with the highest tally for the user's favorite genre. At that point, I will return songs in that genre that the followwee has listened to. If the number of songs is less than 5, I can refer to the next followee or repeat the process for the next genre.
>

What other data could you use to improve recommendations?
- Date at which the song was played
- Artist info for the music
- More genres
- How many times the same song was listened to by a user- to assign higher priority to a song if it was listened to multiple times
- Geographic location of users/followees
- A "star" system for the users to mark their favorite followees
- Which recommendations that the user has taken in the past.
>


Assume a more real world situation where you could have more data you described above, and more time to implement, could you think of a possibly more efficient way to recommend?
I would be utilizing the additional data above to create a more comprehensive algorithm that takes all of it into account. I would look into indexing the database by popular search keys. UserId and MusicId first comes into mind. I would also look into caching information on the client side so that users would not have to constant make queries to the database.
>

Assume you have more than one implementation of recommendations, how could you test which one is more effective using data generated by user actions?
I would track the "follow-through" rate of recommendations that are offered by the two implementations by users. The "follow-through" would ideally be taken from a large data set, and it would be quantifiable (i.e. a % of recommendations that are taken).
>

How long did this assignment take?
I had a day to work on the assignment which ended up being not enough time. This included
studying up on the stack (MongoDB, Node.js, Express.js, Mocha) as well as designing and
implementing. 

Things that still need to be done includes:
- Finishing the script to load in follows.json/listen.json
- Implementing the recommendation algorithm
- Adding more tests, general tidying up of code.
>

Where would be the bottlenecks of this solution you have implemented?
The current "follow" endpoint is designed to facilitate the initialization of the User collection using just a series of subsequent follows relationships (supplied through follows.json). As a result, it is more dense and potentially slower than it could be. I think the better approach would be to have a separate user.json file to initialize all the users, and then utilize /follow only when an existing user chooses to follow another. Moreover, error checking can be performed prior to calling followUser so that the multiple queries (i.e. to determine whether or not a user does or does not exist) would not be necessary.
>

What was the hardest part?
The time constraint was challenging. Fortunately though, the documentation was good and there were some amazing tutorials available on the internet. 

Other than that, the biggest bottleneck that prevented me from completing the assignment was the asynchronous nature of running the script. I have some experiences with Promise objects for React, but that approach did not work for this case. Using the async framework, I was able to get the loading to a point where the initial loads would consistently fail for half of the entries and be successful for the other half. On subsequent loads however, all the loads would be successful. I have not been able to figure out a solution for this.
>

Did you learn something new?
Definitely. This was a really great opportunity to learn up on common frameworks and tools that are commonly used in the industry. After having taken a relational database course, it was really neat to design schemas for MongoDB since they are so flexible in design. 
> 

Do you feel that your skills were well tested?
Yes. The assignment tested a variety of skill sets including algorithm/data structures, database design, testing, and most of all, self-learning.
>
